program
  version
    OPENQASM
    3
    ;
  statementOrScope
    statement
      includeStatement
        include
        "stdgates.inc"
        ;
  statementOrScope
    statement
      quantumDeclarationStatement
        qubitType
          qubit
          designator
            [
            expression
              5
            ]
        targets
        ;
  statementOrScope
    statement
      defStatement
        def
        my_subroutine
        (
        argumentDefinitionList
          argumentDefinition
            scalarType
              int
            a1
          ,
          argumentDefinition
            scalarType
              float
            a2
        )
        returnSignature
          ->
          scalarType
            int
        scope
          {
          statementOrScope
            statement
              ifStatement
                if
                (
                expression
                  expression
                    a1
                  >=
                  expression
                    2
                )
                statementOrScope
                  scope
                    {
                    statementOrScope
                      statement
                        returnStatement
                          return
                          expression
                            0
                          ;
                    }
          statementOrScope
            statement
              ifStatement
                if
                (
                expression
                  expression
                    a2
                  <=
                  expression
                    2
                )
                statementOrScope
                  scope
                    {
                    statementOrScope
                      statement
                        returnStatement
                          return
                          expression
                            0
                          ;
                    }
          statementOrScope
            statement
              returnStatement
                return
                expression
                  1
                ;
          }
  statementOrScope
    statement
      defStatement
        def
        my_subroutine_2
        (
        argumentDefinitionList
          argumentDefinition
            qubitType
              qubit
              designator
                [
                expression
                  5
                ]
            q
        )
        scope
          {
          statementOrScope
            statement
              forStatement
                for
                scalarType
                  int
                i
                in
                [
                rangeExpression
                  expression
                    0
                  :
                  expression
                    4
                ]
                statementOrScope
                  scope
                    {
                    statementOrScope
                      statement
                        gateCallStatement
                          x
                          gateOperandList
                            gateOperand
                              indexedIdentifier
                                q
                                indexOperator
                                  [
                                  expression
                                    i
                                  ]
                          ;
                    }
          }
  statementOrScope
    statement
      defStatement
        def
        xmeasure
        (
        argumentDefinitionList
          argumentDefinition
            qubitType
              qubit
            q
        )
        returnSignature
          ->
          scalarType
            bit
        scope
          {
          statementOrScope
            statement
              gateCallStatement
                h
                gateOperandList
                  gateOperand
                    indexedIdentifier
                      q
                ;
          statementOrScope
            statement
              returnStatement
                return
                measureExpression
                  measure
                  gateOperand
                    indexedIdentifier
                      q
                ;
          }
  statementOrScope
    statement
      constDeclarationStatement
        const
        scalarType
          int
        n
        =
        declarationExpression
          expression
            10
        ;
  statementOrScope
    statement
      defStatement
        def
        parity
        (
        argumentDefinitionList
          argumentDefinition
            scalarType
              bit
              designator
                [
                expression
                  n
                ]
            cin
        )
        returnSignature
          ->
          scalarType
            bit
        scope
          {
          statementOrScope
            statement
              classicalDeclarationStatement
                scalarType
                  bit
                c
                ;
          statementOrScope
            statement
              forStatement
                for
                scalarType
                  int
                i
                in
                [
                rangeExpression
                  expression
                    0
                  :
                  expression
                    expression
                      n
                    -
                    expression
                      1
                ]
                statementOrScope
                  scope
                    {
                    statementOrScope
                      statement
                        assignmentStatement
                          indexedIdentifier
                            c
                          ^=
                          expression
                            expression
                              cin
                            indexOperator
                              [
                              expression
                                i
                              ]
                          ;
                    }
          statementOrScope
            statement
              returnStatement
                return
                expression
                  c
                ;
          }
  statementOrScope
    statement
      defStatement
        def
        array_sub
        (
        argumentDefinitionList
          argumentDefinition
            arrayReferenceType
              readonly
              array
              [
              scalarType
                int
                designator
                  [
                  expression
                    8
                  ]
              ,
              expressionList
                expression
                  2
                ,
                expression
                  10
              ]
            arr1
          ,
          argumentDefinition
            arrayReferenceType
              mutable
              array
              [
              scalarType
                int
                designator
                  [
                  expression
                    8
                  ]
              ,
              #dim
              =
              expression
                1
              ]
            arr2
        )
        scope
          {
          statementOrScope
            statement
              assignmentStatement
                indexedIdentifier
                  aar2
                  indexOperator
                    [
                    expression
                      2
                    ]
                =
                expression
                  10
                ;
          statementOrScope
            statement
              classicalDeclarationStatement
                scalarType
                  uint
                  designator
                    [
                    expression
                      32
                    ]
                dim1
                =
                declarationExpression
                  expression
                    sizeof
                    (
                    expressionList
                      expression
                        arr1
                      ,
                      expression
                        1
                    )
                ;
          statementOrScope
            statement
              classicalDeclarationStatement
                scalarType
                  uint
                  designator
                    [
                    expression
                      32
                    ]
                dim2
                =
                declarationExpression
                  expression
                    sizeof
                    (
                    expressionList
                      expression
                        expression
                          arr1
                        indexOperator
                          [
                          expression
                            0
                          ]
                      ,
                      expression
                        0
                    )
                ;
          }
  statementOrScope
    statement
      classicalDeclarationStatement
        scalarType
          int
        result
        =
        declarationExpression
          expression
            my_subroutine
            (
            expressionList
              expression
                1
              ,
              expression
                5
            )
        ;
  statementOrScope
    statement
      expressionStatement
        expression
          my_subroutine_2
          (
          expressionList
            expression
              targets
          )
        ;
  statementOrScope
    statement
      assignmentStatement
        indexedIdentifier
          result
        =
        expression
          xmeasure
          (
          expressionList
            expression
              expression
                targets
              indexOperator
                [
                expression
                  0
                ]
          )
        ;
  statementOrScope
    statement
      quantumDeclarationStatement
        qubitType
          qubit
        q
        ;
  statementOrScope
    statement
      quantumDeclarationStatement
        qubitType
          qubit
        r
        ;
  statementOrScope
    statement
      classicalDeclarationStatement
        scalarType
          bit
        c
        =
        declarationExpression
          measureExpression
            measure
            gateOperand
              indexedIdentifier
                q
        ;
  statementOrScope
    statement
      classicalDeclarationStatement
        scalarType
          bit
        c2
        =
        declarationExpression
          measureExpression
            measure
            gateOperand
              indexedIdentifier
                r
        ;
  statementOrScope
    statement
      classicalDeclarationStatement
        scalarType
          bit
          designator
            [
            expression
              2
            ]
        param
        ;
  statementOrScope
    statement
      assignmentStatement
        indexedIdentifier
          param
          indexOperator
            [
            expression
              0
            ]
        =
        expression
          c
        ;
  statementOrScope
    statement
      assignmentStatement
        indexedIdentifier
          param
          indexOperator
            [
            expression
              1
            ]
        =
        expression
          c2
        ;
  statementOrScope
    statement
      classicalDeclarationStatement
        scalarType
          bit
        result
        ;
  statementOrScope
    statement
      assignmentStatement
        indexedIdentifier
          result
        =
        expression
          parity
          (
          expressionList
            expression
              param
          )
        ;
  statementOrScope
    statement
      classicalDeclarationStatement
        arrayType
          array
          [
          scalarType
            int
            designator
              [
              expression
                8
              ]
          ,
          expressionList
            expression
              3
            ,
            expression
              5
          ]
        my_arr1
        ;
  statementOrScope
    statement
      classicalDeclarationStatement
        arrayType
          array
          [
          scalarType
            int
            designator
              [
              expression
                8
              ]
          ,
          expressionList
            expression
              5
          ]
        my_arr2
        ;
  statementOrScope
    statement
      expressionStatement
        expression
          array_sub
          (
          expressionList
            expression
              my_arr1
            ,
            expression
              my_arr2
          )
        ;
  <EOF>