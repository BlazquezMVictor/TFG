Como va el modulo de simpy?
	- es ese realmente el modulo? Porque por lo que vi se usa para simulaciones con procesos y gestion de recursos, etc
	- RESPUESTA
		- El modulo es sympy
		- En la carpeta conectores	
			- parser.py
			- conectores.py

Tiene algun tipo de datos para los angulos?
	- float, uint, int, etc
	- se aceptan angulos negativos?
	- RESPUESTA
		- Qsimov acepta lo que le eches
		- Float sirve y mirar lo de sympy porque los parámetros en wismov van en string

Hay que usar siempre el QSystem?
	- Se pueden hacer circuitos sin el?
		- Como existe el QRegistry, etc.
	- RESPUESTA
		- Deberia centrarme en QCircuit y empezar siempre por ahi

Hay operaciones que se hagan teniendo en cuenta tiempo, es decir, un delay?
	- Por los tipos de datos duration y strech
		- OpenQASM3.0 lo usa apra alinear operaciones en el tiempo
	- RESPUESTA
		- Ignorarlo o como máximo usar un sleep

Ignoro las operaciones de tipo pulso sobre un qubit físico?
	- Como Qsimov simula, no usa un ordenador cuantico real con qubits fisicos, tiene sentido traducir estas sentencias?
	- RESPUESTA
		- Ignorarla y lanzar UnsupportedOperationException

Que opinan sobre usar el parser gramatico de openqasm
	- Me devuelve una string con estrucutura de arbol donde me pone el analizador lexico y sintactico y los que sean
	- RESPUESTAS
		- Es una buena opción
		- En tiempo de ejecucion puedo modificar variables de entorno con el modulo os
			- Seria automatizarlo al final

Posible problematica con el parametro 'fun' del metodo 'add_gate' puesto que en la traduccion se indica una direccion de memoria
	-RESPUESTAS
		- Probar a ver si funciona con la dirección de memoria
			- Para ver si funciona siempre, llamar a gc.collect antes de ejecutar el código traducido
		- Si no va, otra opción es meter en la traducción la función que devuelve la matriz, y entonces en el add_gate llamar a la función

Para la traducción de la operacion 'gphase'
	- RESPUESTAS
		- Usar una matriz identidad donde la diagonal es e elevado a lo que me dijo hernan
		- Hago una función que recibe el ángulo y devuelve la matriz para añadir la puerta
			- En min y max args pongo el valor de la cantidad de ángulos

En cuanto a la operación de reset
	- RESPUESTAS
		- Más allá de la inicialización, se supone que no está soportado en ningún sitio más
		- Probar si de verdad en openQASM se puede hacer a mitad del circuito
			- Hacer un par de Bell, resetear uno y medir
			- Probarlo en Qiskit

Como puedo generar una puerta propia con parametros (angulos)?
	- Que tal hacer un def cuyo nombre es la puerta custom y de parametros recibe los del openqasm
	- Y dentro de la funcion creamos la QGate y añadimos las operaciones pertinentes
	- Y finalmente se añade la operacion donde la puerta es una llamada a esta funcion
	- RESPUESTA
		- La propuesta les ha gustado

La matriz inversa es especial o se puede calcular con numpy por ejemplo (inverse = np.linalg.inv(matrix))
	-RESPUESTA
		- No es eficiente con puertas grandes
		- Mejor hacer las traspuesta y después conjugarla

Sobre los modificadores 'inv' y 'pow'
	- RESPUESTA
		- pow
			- Si el exponente es entero basta con aplicar la misma puerta tantas veces
			- Spoiler: Puede ser float tambien
		- inv
			- Igual que pow, y si se aplica una vez mas se obtiene la identidad

En OpenQASM hay una instruccion 'end' que terminar el programa, se llame desde donde se llame, tiene sentido que la implemente?
	- RESPUESTA
		- Hernan la añadio hace poco

Tambien tiene llamadas a funciones externas, pero no he visto ejemplos y en la documentacion solo explica como usarlas, la implemento?
	- RESPUESTA
		- Centremonos en las cosas bien documentada

Tienen 'pragmas' para indicar cierta informacion especifica de las herrmaientas que el usuario usar
	- Para el modelo de ruido
	- Para la maxima temperatura de la qpu
	- Para añadir infor extra
		- pragma user alice account 12345678

	- RESPUESTA
		- Podemos ignorarlo de momento

Tambien tienen anotaciones para una funcion similar
	- @reversible indica que el compilador debe crear una puerta reversible de la que se esta creando justo debajo

	- RESPUESTA
		- Ignorarlo tambien

Tambien estan las keywords 'input' y 'output' que se utilizan para indicar que variables se van a usar como inputs y outputs del circuito 
	- Esto permite poder tener el circuito como un ejecutable y comunicarlo con otros circuitos?
	- Asi solo se compila una vez el circuito y se puede correr varias veces con diferentes combinaciones de esos parámetros

	- RESPUESTA
		- No lo tenemos en cuenta


Tiene sentido meter bits clasicos dada esta situacion
	- def parity(bit[n] cin) -> bit {
		bit c;
		for int i in [0: n - 1] {
			c ^= cin[i];
		}
		return c;
	}

	- RESPUESTA
		- Mejor no añadrilo y usar una varibale booleana o binaria o lo que sea

NOTAS
- Hacer una primera identificaion en funcionalidades
	- Aqui openqasm hace una declaracion, como esta cubierta esta declaracion en qsimov
		- Despues bajamos de nivel y vemos que palabras son las correctas y el orden en el que deben ir

- QGate es como un QCircuit pero no acepta operaciones no reversibles
	- QGate permite crear una puerta a partir de otras puertas

- SimpleGate permite crear puertas custom pero a partir de una matriz

- El parámetro 'has_invert_arg' de la función 'add_gate' dejarlo en False
	- True significa que soy yo quien calcula la inversa de la matriz

- Para las pruebas
	- Deben estar bien documentadas
		- Se han diseñado esta serie de pruebas para evaluar tal cosas

	- Hacer pruebas con puertas de un solo qubit en un estado arbitrario
		- Luego usar circuitos mas grandes con conjuntos de puertas

	- Mirar si pennylein de sanadu soporta openQASM3.0

- Para la memoria con scrum
	- Mencionar que he usado una adaptacion
	- Tengo una pila de producto, una lista de tareasa
		- Ordenarla segun importancia
	- Cada tarea la he hecho en tal sprint
		- Los sprints son de un tamaño fijo
		- Si algo no finaliza en un srpint se pasa al siguiente
		- Si has terminado todo antes del plazo, planificarlo mejor la proxima
	- Hay varias reuniones
		- Sprint planning
			- Planeo de lo que se hace en el sprint
			- Coger por orden de importancia pero no obligatorio, podemos coger 1, 2 y 4
		- Sprint review
			- Revision de los avances por todos los interesados
		- Restrospective
			- Para ver como ha funcionado esta metodologia
		- Daily scrum
			- Equipo y scrum master se reunen para contar cada uno un poco de como va
			- 10 min antes de trabajar
		- Scrum refinement o algo asi
			- Con el product owner con desarrolladores
			- Product owner dice estas tareas son las que mas importancia tiene y desarrolladores dice tiempo
			- Si hay una tarea muy larga se divide en mas sencillas


	- Hernan dice que usar sprints de dos semanas

	- Hacer documentacion o testing no es un item de la pila
	- Se considera que un item esta compleatado si cumple la definicion de hecho
		- La definicion puede ser que el item se haya testeado tanto y se haya documentado tanto

	- Pila producto esta ordenada de mayor a menor importancia
		- En el sprint planning se decide cuantas de esa tareas se cogen en funcion del tiempo y complejidad

	- Se pueden añadir cosas que nos han pasado
		- En review
		- Hemos descurbierto que hay esta nueva funcionalidad asi que se ha añadido a la pila

	- La pila de sprint son tareas de la pila de producto
		- Las terminadas bien
		- Las no acabadas se devuelven a la pila de producto

	- Buscar la rubrica para evaluar el TFG